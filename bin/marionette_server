#!/usr/bin/env python
# coding: utf-8

import sys
import time
import threading

from twisted.internet import defer
from twisted.internet import protocol
from twisted.internet import reactor
from twisted.python import log
from twisted.internet import task

sys.path.append(".")

import marionette

REMOTE_IP   = str(sys.argv[1])
REMOTE_PORT = int(sys.argv[2])

format = 'http_simple_blocking'
server = marionette.Server(format)
server.start()

class ProxyServerProtocol(protocol.Protocol):
    def __init__(self):
        self.connected = False

    def connectionMade(self):
        log.msg("ProxyServerProtocol: connected to peer")
        self.cli_queue = self.factory.cli_queue
        self.cli_queue.get().addCallback(self.serverDataReceived)
        self.connected = True

    def serverDataReceived(self, chunk):
        if chunk is False:
            self.cli_queue = None
            log.msg("ProxyServerProtocol: disconnecting from peer")
            self.factory.continueTrying = False
            self.transport.loseConnection()
        elif self.cli_queue:
            log.msg("ProxyServerProtocol: writing %d bytes to peer" % len(chunk))
            self.transport.write(chunk)
            self.cli_queue.get().addCallback(self.serverDataReceived)
        else:
            log.msg("ProxyServerProtocol: (2) writing %d bytes to peer" % len(chunk))
            self.factory.cli_queue.put(chunk)

    def dataReceived(self, chunk):
        log.msg("ProxyServerProtocol: %d bytes received from peer" % len(chunk))
        self.factory.srv_queue.put(chunk)

    def connectionLost(self, why):
        log.msg("ProxyServerProtocol.connectionLost: " + str(why))
        if self.cli_queue:
            self.cli_queue = None
            log.msg("ProxyServerProtocol: peer disconnected unexpectedly")
        self.connected = False

    def isConnected(self):
        return self.connected


class ProxyServerFactory(protocol.ClientFactory):
    maxDelay = 10
    continueTrying = True
    protocol = ProxyServerProtocol

    def __init__(self, srv_queue, cli_queue):
        self.srv_queue = srv_queue
        self.cli_queue = cli_queue


class ServerThread(threading.Thread):
    def __init__(self, stream_id):
        threading.Thread.__init__(self)
        self.stream_id_ = stream_id

    def run(self):
        while True:
            stream = server.get_stream(self.stream_id_)
            if not stream or not stream.is_active(): break
            while stream.peek():
                chunk = server.get_stream(self.stream_id_).pop()
                factories[self.stream_id_][0].cli_queue.put(chunk)
                time.sleep(0)

        factories[self.stream_id_][1].disconnect()
        del factories[self.stream_id_]
        server.terminate_stream(self.stream_id_)

    def clientDataReceived(self, chunk):
        log.msg("ServerThread.clientDataReceived: writing %d bytes to original client" % len(chunk))
        server.get_stream(self.stream_id_).push(chunk)
        factories[self.stream_id_][0].srv_queue.get().addCallback(self.clientDataReceived)


factories = {}
def checkForNewStreams():
    for stream_id in server.get_streams().keys():
        if not factories.get(stream_id):
            t = ServerThread(stream_id)

            srv_queue = defer.DeferredQueue()
            cli_queue = defer.DeferredQueue()
            srv_queue.get().addCallback(t.clientDataReceived)
            factory = ProxyServerFactory(srv_queue, cli_queue)
            connector = reactor.connectTCP(REMOTE_IP, REMOTE_PORT, factory)
            factories[stream_id] = [factory, connector]

            t.start()

if __name__ == "__main__":
    log.startLogging(sys.stdout)
    l = task.LoopingCall(checkForNewStreams)
    l.start(0.1)
    reactor.run()
